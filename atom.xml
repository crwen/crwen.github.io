<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crwen</title>
  
  
  <link href="http://crwen.github.io/atom.xml" rel="self"/>
  
  <link href="http://crwen.github.io/"/>
  <updated>2021-08-01T15:04:22.026Z</updated>
  <id>http://crwen.github.io/</id>
  
  <author>
    <name>crwen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数调用过程</title>
    <link href="http://crwen.github.io/2021/08/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://crwen.github.io/2021/08/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-08-01T15:02:33.000Z</published>
    <updated>2021-08-01T15:04:22.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>&emsp;对于一个过程(函数/方法)，必须要支持下面一个或多个机制：</p><ul><li>传递控制：自动更新程序计数器 PC 的值</li><li>传递数据：提供参数传递和结果返回功能</li><li>分配和释放内存：提供内存的分配和释放机制</li></ul><span id="more"></span><h3 id="传递控制"><a href="#传递控制" class="headerlink" title="传递控制"></a>传递控制</h3><p>&emsp;在传递控制部分，我们需要做的事情是自动更新程序计数器 PC 的值，让程序能够按照正确的顺序执行。要做到自动更新 PC 的值，我们需要做到下面两点：</p><ol><li>调用过程前将返回地址压栈，以便被调过程返回时能够继续执行。同时将 PC 的值设置为被调函数的首地址值，以便程序能够执行被调函数</li><li>被调函数返回时，将返回地址弹栈，并将 PC 的值设置为这个返回地址，以便程序能从调用位置够继续执行</li></ol><p>&emsp;在 x86-64 中，分别使用 <code>call</code> 指令和 <code>ret</code> 指令来实现这两个功能。</p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>在过程的调用过程中，后调用的过程一般会先执行完毕，所有程序一般都会使用栈作为数据结构来管理内存。一个过程可能会有许多信息，这部分信息也需要存储在栈上，这一部分称之为栈帧。一个通用栈帧示意图如下图所示。</p><img src="/2021/08/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/Users\crwen\AppData\Roaming\Typora\typora-user-images\image-20210801230050062.png" alt="image-20210801230050062" style="zoom:67%;"><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>&emsp;在 x86-64 中，可以通过寄存器最多传递 6 个整型参数，而这些寄存器是有顺序。过程中传递的参数依次存放到寄存器 %rdi、%rsi、%rdx、%rcx、%r8、%r9 中。如果一个函数有大于6 个整型参数，超出 6 个的部分需要通过栈来传递，并且这些数据大小都需要向 8 的倍数对齐。如果在过程中调用了某个超过了 6 个参数的函数，则需要在栈帧中为超过 6 个部分的参数分配过程，这一部分称之为“参数构造区”。</p><p>&emsp;对于下面的程序，函数 proc 接受 8 个参数，包括字节数不同的整数和不同类型的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">long</span>  a1, <span class="keyword">long</span>    *a1p,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>     a2, <span class="keyword">int</span>     *a2p,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">short</span>   a3, <span class="keyword">short</span>   *a3p,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span>    a4, <span class="keyword">char</span>    *a4p)</span> </span>&#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;我们查看汇编代码（原始的、为被优化的代码，并且只保留了重要部分）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proc:</span><br><span class="line">.LFB0:</span><br><span class="line">movq16(%rsp), %rax; 将 a4 放入 %rax 中</span><br><span class="line">addq%rdi, (%rsi)   ; *a1p +&#x3D; a1</span><br><span class="line">addl%edx, (%rcx)  ; *a2p +&#x3D; a2</span><br><span class="line">addw%r8w, (%r9); *a3p +&#x3D; a3</span><br><span class="line">movl8(%rsp), %edx; 将 a4 存放到 %edx 中</span><br><span class="line">addb%dl, (%rax) ; *a4p +&#x3D; a4</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>&emsp;从汇编代码中可以看出，参数 a1, *a1p, a2, *a2p, a3, *a3p 分别存放在寄存器 %rdi、%rsi、%rdx、%rcx、%r8、%r9 中。而我们通过 <code>8(%rsp)</code> 和 <code>16(%rsp)</code> 分别访问了 a4 和 *a4，并且我们发现这两个参数在栈中是逆序存储的。由此可以证明，过程的前 6 个整型参数是通过寄存器传递的，而超过 6 个的部分是通过栈来存储的。</p><blockquote><p>&emsp;在 x86-32 中没有使用寄存器来传递参数，所有参数都需要在栈上分配。可以通过 -m32 来指定编译为 32 位机器上的代码，然后查看汇编代码来验证。也可以通过<a href="https://blog.csdn.net/u010039418/article/details/85275211">这篇博客</a>了解</p></blockquote><p>&emsp;既然参数会使用寄存器存储，而且通用寄存器是公用的，那么如果我们在被调用函数中改变了寄存器中的值会影响参数原本的值吗。根据我们的经验，值传递是不会改变变量原来的值的。那么程序是如何做到这一点的呢？</p><p>&emsp;要想保证值不被其他函数修改，只有两种方法</p><ol><li>在调用函数前保存一份，函数返回后恢复，这种方式被称为<strong>调用者保存</strong></li><li>在被调函数中保存，返回前恢复，这种方式被称为<strong>被调用者保存</strong></li></ol><p>&emsp;在 x86 中，通用寄存器被划分为调用者保存和被调用者保存两类，其中寄存器 %rbx、%rbp 和 %r12~%15 是被调用者保存，其他寄存器位调用者保存。在需要保存寄存器中的值的时候，这些值也是保存在栈上的。</p><h4 id="局部变量存储"><a href="#局部变量存储" class="headerlink" title="局部变量存储"></a>局部变量存储</h4><p>&emsp;对于过程中的局部变量，有些可以直接使用寄存器存取，但是有些变量需要存储在栈上，常见的情况包括：</p><ul><li>寄存器不足够存放所有的本地数据</li><li>对一个局部变量使用取地址运算符 &amp;，这时不能能够为它产生一个地址</li><li>某些局部变量数组或结构</li></ul><h2 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p>&emsp;在 C 语言中，数组是一种将标量数据聚集程更大数据类型的方式，也就是说数组中的元素是分配在一块连续的内存空间中的。</p><p>&emsp;对于数据类型 T ，有一维数组 <code>T A[N]; </code>，假设数组首地址为 X<sub>A</sub>，则数组中第 i 个元素存放在 X<sub>A</sub> + L * i 中（L 为 数据类型 T 的大小）。如果有二维数组 <code>T A[M][N]</code>，则数组元素 <code>A[i][j]</code> 计算地址的方式为 X<sub>A</sub> + L (N * i + j)。也就是说数组元素是按照“行优先”的顺序存放的。</p><p><strong>参考资料</strong></p><p>[深入理解计算机系统](<a href="https://book.douban.com/subject/26912767/">深入理解计算机系统（原书第3版） (豆瓣) (douban.com)</a>)</p><p><a href="https://blog.csdn.net/u010039418/article/details/85275211">Linux X86架构参数传递规则</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;过程调用&quot;&gt;&lt;a href=&quot;#过程调用&quot; class=&quot;headerlink&quot; title=&quot;过程调用&quot;&gt;&lt;/a&gt;过程调用&lt;/h1&gt;&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;p&gt;&amp;emsp;对于一个过程(函数/方法)，必须要支持下面一个或多个机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递控制：自动更新程序计数器 PC 的值&lt;/li&gt;
&lt;li&gt;传递数据：提供参数传递和结果返回功能&lt;/li&gt;
&lt;li&gt;分配和释放内存：提供内存的分配和释放机制&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CS" scheme="http://crwen.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://crwen.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>Rust 基础语法</title>
    <link href="http://crwen.github.io/2021/07/15/Rust-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://crwen.github.io/2021/07/15/Rust-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2021-07-15T12:41:32.000Z</published>
    <updated>2021-07-15T12:59:27.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-基础"><a href="#Rust-基础" class="headerlink" title="Rust 基础"></a>Rust 基础</h1><blockquote><p>Rust 是由 Mozilla 主导开发的一种通用的编译型编程语言，它支持函数式、并发式、过程式以及面向对象的编程风格。它的设计目标之一是使设计大型互联网客户端和服务器的任务变得更容易。因此更加强调安全性、存储器配置以及并发处理等方面的特性。</p></blockquote><span id="more"></span><h2 id="Rust-基础语法"><a href="#Rust-基础语法" class="headerlink" title="Rust 基础语法"></a>Rust 基础语法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>rustc main.rs</code> 来编译这个程序，得到一个可执行文件</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>&emsp;在 Rust 中，可以使用 <code>let</code> 来声明一个变量，用 <code>let</code> 声明的变量默认是不可变的，即不能改变它的值。如果尝试修改一个不可变量的值，编译时会出现 <code>cannot assign twice to immutable variable xxx</code> 的错误。如果希望在以后修改变量的值，可以使用 <code>mut</code> 来修饰变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// rust 中变量默认不可变</span></span><br><span class="line"><span class="comment">// a = 2;// error !!!</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span>  a= <span class="number">3</span>;  <span class="comment">// 可以使用 mut 使变量可变</span></span><br><span class="line">b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>Rust 允许重复定义一个变量来隐藏（shadow）之前的值，比如在上面的代码中我们使用 <code>let mut a</code> 隐藏了 <code>let a = 5</code> 的声明。这个功能常用在需要转换值类型的场景，这样我们就可以复用变量的名字了。</p><p>有人可能会想，不可变变量与常量有什么区别呢？还是说在 rust 中是用不可变变量代替常量的呢？</p><p>在 rust 中常量与不可变变量还是有区别的，他们的区别如下：</p><ul><li>声明常量使用 <code>const</code> 关键字，并且必须注明值类型，声明变量使用 <code>let</code> 关键字</li><li>不能用 <code>mut</code> 修饰常量，但是可以用 <code>mut</code> 修饰不可变量</li><li>常量可以在任何作用域中声明</li><li>常量只能被设置为常量表达式，不能是函数调用的结果或者是其他只能在运行时计算出的值</li></ul><p>一个常量声明的例子如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="built_in">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>Rust 是静态类型语言，所以在编译时就必须知道所有变量的类型。Rust 将变量大致分为两种类型：标量（scalar）和复合（compound）</p><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>标量类型代表要给单独的值，在 Rust中有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。</p><p><strong>整型</strong></p><p>整型数据表示一个整数，分为有符号数据和无符号数据。有符号数据一般以 i 开头，比如 <code>i32</code>，无符号整数一般以 u 开头，比如 <code>u32</code>。如果没有指定整数的数据类型，默认使用 <code>i32</code>。Rust 中支持的整数类型如下表所示：</p><table><thead><tr><th align="center">长度</th><th align="center">有符号</th><th align="center">无符号</th></tr></thead><tbody><tr><td align="center">8bit</td><td align="center"><code>i8</code></td><td align="center"><code>u8</code></td></tr><tr><td align="center">16bit</td><td align="center"><code>i16</code></td><td align="center"><code>u16</code></td></tr><tr><td align="center">32bit</td><td align="center"><code>i32</code></td><td align="center"><code>u32</code></td></tr><tr><td align="center">64bit</td><td align="center"><code>i64</code></td><td align="center"><code>u64</code></td></tr><tr><td align="center">128bit</td><td align="center"><code>i128</code></td><td align="center"><code>u128</code></td></tr><tr><td align="center">arch</td><td align="center"><code>isize</code></td><td align="center"><code>usize</code></td></tr></tbody></table><blockquote><p><code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构，在 64 位机器上是 64 位，在 32 位机器上是 32 位</p></blockquote><p>整型数据的定义可以参照如下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">57i8</span>; <span class="comment">// i8 </span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">123</span>; <span class="comment">// i32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decimal = <span class="number">100_000</span>;<span class="comment">// 十进制 </span></span><br><span class="line"><span class="keyword">let</span> hex = <span class="number">0x36ff</span>;<span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> octal = <span class="number">0o77</span>;<span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> binary = <span class="number">0b1111_0001</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> byte = <span class="string">b&#x27;A&#x27;</span>;<span class="comment">// 单字节字符</span></span><br></pre></td></tr></table></figure><p><strong>浮点型</strong></p><p>同其他语言一样，Rust 也有两种浮点数类型，分别为 <code>f32</code> 和 <code>f64</code>，如果没有指定类型，默认位 <code>f64</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br></pre></td></tr></table></figure><p><strong>布尔类型</strong></p><p>Rust 中的布尔类型有两个可能的值 <code>true</code> 和 <code>false</code>，可以使用 <code>bool</code> 来指定类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> f: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><strong>字符类型</strong></p><p>字符类型使用单引号表示，占四个字节，代表一个 Unicode 标量值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>复合类型可以将多个值组合成一个类型。Rust 中有两个原生的复合类型：元组（tuple）和数组（array）</p><p><strong>元组类型</strong></p><p>元组可以将多个其他类型的值组合在一起。元组的长度固定，一旦声明，其长度不会改变你</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup; <span class="comment">// 解构 destructuring</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;, z = &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;tup: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组类型</strong></p><p>与元组不同，数组中每个元素的类型必须相同，但是数组的长度也是固定的，一旦声明，长度不会改变。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> b = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// 声明一个长度为 5 数组，数组所有元素初始值为 3</span></span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// name: [type; len]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在 Rust 中通过 <code>fn</code> 关键字来声明函数，这个函数可以定义在调用点之前或者之后。</p><p>在函数的签名中，形参必须指定类型。多个参数可以使用逗号 <code>,</code> 分离</p><p>函数体由语句和表达式构成。语句是执行一些操作但不返回的指令，而表达式计算并产生一个值。比如 <code>let x = 1 + 2</code> 是一个语句，而 <code>1 + 2</code> 是一个表达式。</p><p>函数使用 <code>-&gt; type</code> 来指定返回类型，如果不使用 <code>return</code> 关键之返回，函数隐式地返回函数体最后一个表达式的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(arg: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = arg; <span class="comment">// let x = 5 是一个语句</span></span><br><span class="line">    <span class="keyword">let</span> y = &#123;  <span class="comment">// &#123;...&#125; 是一个表达式，返回 4</span></span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    y <span class="comment">// 隐式返回 ，表达式后无需分号 ;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y = foo(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">    <span class="keyword">let</span> f = foo;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;foo(&#123;&#125;) = &#123;&#125;&quot;</span>, <span class="number">4</span>, f(<span class="number">4</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>控制流可以根据条件来执行某些代码，最常见的是分支和循环。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><code>if</code> 表达式允许根据条件执行不同的代码分支，这一点与其他语言类似，但是 Rust 中条件不需要用 () 括起来，而且条件必须是一个 <code>bool</code> 值。同时分支体必须使用大括号 {} 包裹起来。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gcd</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为 <code>if</code> 是一个表达式，所以会计算出一个值，我们可以使用一个变量来接受</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        gcd(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gcd(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;res = &#123;&#125;&quot;</span>, res); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Rust 提供了三种循环，一种是 <code>loop</code> 循环，一种是 <code>while</code> 循环，还有一种是 <code>for</code> 循环。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;this is a dead loop&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> idx = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> idx &lt; arr.jlen() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>， arr[idx]);</span><br><span class="line">        idx = idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cargo"><a href="#cargo" class="headerlink" title="cargo"></a>cargo</h2><p>cargo 是 Rust 的一个包管理器，使用它可以构建项目、下载并编译依赖。</p><ul><li>cargo new: create your project</li><li>cargo build: build your project</li><li>cargo run: run your project</li><li>cargo check: check your project</li><li>cargo test: test your project</li><li>cargo doc: build documentation for your project</li><li>cargo publish: publish a library to crates.io</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust-基础&quot;&gt;&lt;a href=&quot;#Rust-基础&quot; class=&quot;headerlink&quot; title=&quot;Rust 基础&quot;&gt;&lt;/a&gt;Rust 基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Rust 是由 Mozilla 主导开发的一种通用的编译型编程语言，它支持函数式、并发式、过程式以及面向对象的编程风格。它的设计目标之一是使设计大型互联网客户端和服务器的任务变得更容易。因此更加强调安全性、存储器配置以及并发处理等方面的特性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://crwen.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://crwen.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="http://crwen.github.io/2021/03/21/longest-increase-subsequence/"/>
    <id>http://crwen.github.io/2021/03/21/longest-increase-subsequence/</id>
    <published>2021-03-21T14:39:15.000Z</published>
    <updated>2021-05-08T13:44:39.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><span id="more"></span><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>暴力解法就是枚举出所有的递增字串，从字串中获取长度最长的。暴力解法有点像全排列，只不过加了一个限制，当前数字必须比前面的都要大。暴力解法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="comment">// private List&lt;List&lt;Integer&gt;&gt; sequences = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LISForce</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    getAllSubsequence(arr, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAllSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    ans = Math.max(ans, list.size());</span><br><span class="line">    <span class="comment">// sequences.add(new ArrayList&lt;&gt;(list));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span> || arr[i] &gt; list.get(list.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">            list.add(arr[i]);</span><br><span class="line">            getAllSubsequence(arr, i + <span class="number">1</span>, list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种暴力的方法的时间复杂度为 O(2<sup>n</sup>)，显然这个复杂度太高了，我们需要想一个复杂度更低的方法。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>现在我们只考虑以下标为 index 结尾的最长递增子序列的，然后求出以所有以 index 结尾的最长递增子序列长度的最大值，不就是全局最大值吗？那么怎么求呢？你可能会想到暴力方法，遍历 0 到 index-1 的所有元素，如果当前元素比前面的元素大，我们就可以在前面得到结果的基础上 + 1 作为自己的结果。这个结果可能有好几个，我们取最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LISDP</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(dp[i], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的时间复杂度是 O(n<sup>2</sup>)，比上面的暴力方法好多了。</p><h3 id="二分优化"><a href="#二分优化" class="headerlink" title="二分优化"></a>二分优化</h3><p>我们再换一种思考方式，我们认为长度为 n 的递增子序列的结尾值越小越好，这样就更可能与后面的值形成更长的递增子序列了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; dp[k]) &#123;</span><br><span class="line">            dp[++ k] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = searchRight(dp, nums[i], <span class="number">0</span>, k );</span><br><span class="line">            <span class="keyword">if</span> (dp[index] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[index] &gt; nums[i]) &#123;</span><br><span class="line">                dp[index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchRight</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。&lt;/p&gt;
&lt;p&gt;子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://crwen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://crwen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://crwen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>中断机制</title>
    <link href="http://crwen.github.io/2021/03/19/%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://crwen.github.io/2021/03/19/%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-03-19T15:55:12.000Z</published>
    <updated>2021-03-20T07:58:41.505Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在计算机就科学中，中断是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。</p><p>通常，在接收到来自外围设备的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件/软件处理。发出这样的信号称为进行中断请求。硬件中断导致处理器通过一个 context switch 来保存执行状态；软件中断则通常作为 CPU 指令集中的一个指令，以可编程的方式直接只是这种运行信息切换，并将处理导向一段中断处理代码</p></blockquote><span id="more"></span><p>中断通常被称为<strong>同步中断</strong>和<strong>异步中断</strong></p><ul><li>同步中断，也叫做异常，是指令执行时由 CPU 产生的，只有在一条指令终止执行后 CPU 才会发出中断</li><li>异步中断，也叫做（外部）中断，是由其他硬件设备依照 CPU 时钟信号随机产生的</li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断，即异步中断，是其他硬件按照 CPU 时钟信号随机产生的，比如事件中断、I/O 中断。例如用户的一次按键会引起一个中断。之所以称为异步中断，是因为当硬件生成中断时，中断处理器与当前运行的进程在 CPU 上没有任何关联，CPU 和生成中断的设备时并行运行的。</p><p>中断提供了一种特殊的方式，使处理器转而去运行正常的控制流之外的代码。当一个中断信号到达时，中断控制器会通知当前有一个待处理的中断，其中一个 CPU 会接收中断，调用相应的中断处理程序处理中断。中单处理完成后，CPU 会通知中断控制器中断完成。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常，即同步中断，是指令执行 CPU 控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后 CPU 才会发出中断。按引起异常的指令是否能重新执行，且依据他们被报告的方式，异常可以被分为错误、陷阱和终止三种情况</p><ul><li>错误：错误是一种能够被修正的异常，一旦修正，程序能够接着执行，比如页错误</li><li>陷阱：当程序执行系统调用时，会 trap 到内核态</li><li>终止：它并不总是报告产生异常的指令的确定位置，也不允许引起终止的进程或任务重新执行，如总线错误导致异常终止。</li></ul><h4 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h4><p>当程序执行系统调用时会导致用户空间和内核空间的切换，这个切换被称为 trap。在这个过程种，需要进行保存用户寄存器的信息、程序计数器等信息，这些信息表明了执行系统调用时计算机的状态。在 trap 处理的过程中，我们需要更改这些状态，或者对状态做一些操作，这样我们才能运行内核中的程序。一般 trap 的处理过程需要做以下事情：</p><ul><li>保存用户寄存器，因为我们希望在下次恢复执行的时候能够恢复此时的状态这就意味着用户寄存器不能被内核修改，所以我们需要保存他们</li><li>保存程序计数器，程序计数器指示着当前执行指令的位置，为了让程序恢复执行时知道从何处接着执行，我们也需要保存程序计数器的值</li><li>更改用户模式，因为要从用户空间切换到内核空间，所以我们需要修改处理器的标识位，以便使用内核中的特权指令</li><li>跳入内核</li></ul><p>当一个系统调用发生时，用户空间通过向内核空间发出 <code>syscall</code> 产生软中断（int80），让程序陷入到内核态，跳到内核中一个固定的位置。陷入内核后，在中断向量表中根据中断识别码查询到相应的中断处理程序，调用相应的系统调用。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在计算机就科学中，中断是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。&lt;/p&gt;
&lt;p&gt;通常，在接收到来自外围设备的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件/软件处理。发出这样的信号称为进行中断请求。硬件中断导致处理器通过一个 context switch 来保存执行状态；软件中断则通常作为 CPU 指令集中的一个指令，以可编程的方式直接只是这种运行信息切换，并将处理导向一段中断处理代码&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://crwen.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://crwen.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程切换</title>
    <link href="http://crwen.github.io/2021/03/19/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <id>http://crwen.github.io/2021/03/19/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</id>
    <published>2021-03-18T16:45:41.000Z</published>
    <updated>2021-03-20T06:11:28.817Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;进程是操作系统的核心，通过进程基本可以将操作系统的所有知识联系起来。而线程是一种轻量级的线程，学习线程对学习进程是很有帮助的。</p><span id="more"></span><p>&emsp;首先我们思考一个问题：计算机运行为什么需要多线程呢？</p><ul><li>首先，人们希望一个进程在同一时间不是执行一个任务。比如 QQ 在上传文件的同时，还需要确保能够正常聊天</li><li>其次，多线程让程序的结构变得简单。线程在有些场合可以帮助程序员以简单优雅的方式进程组织，并减少复杂度</li><li>最后，使用多线程可以实现并行运算，在多核 CPU 中可以加快处理的速度。</li></ul><h2 id="user-kernel-mode"><a href="#user-kernel-mode" class="headerlink" title="user/kernel mode"></a>user/kernel mode</h2><p>&emsp;处理器有两种模式，一种是 user mode，第二种是 kernel mode。当运行在 kernel mode 时，CPU 可以运行<strong>特权指令</strong>（privileged instructions）；当运行在 user mode 时，CPU 只能运行普通指令，即<strong>非特权指令</strong>。</p><p>&emsp;普通指令指的是像 ADD、SUB、JRC、BRANCH 这样所有应用程序都允许执行的指令。而特权指令主要是一些直接操纵硬件的指令和设置保护的指令，比如设置 page table 寄存器、关闭时钟中断等。</p><p>&emsp;在处理器中有一个 flag 用来标志指令是否是特权指令。同时处理器中有一个 bit，用来标识是 user mode 还是 kernel mode。当处理器解析指令时，如果发现 user mode 尝试执行特权指令，处理器会拒绝执行这条指令。</p><p>&emsp;现在，我们知道当应用程序尝试执行特权指令时会被处理器拒绝掉，而且如果想要修改处理器中的 bit 位也需要执行特权指令，那么如何才能让应用程序执行内核才能执行的内核指令呢？</p><p>&emsp;如果用户空间尝试执行一条特权指令，用户程序会通过<strong>系统调用</strong>来切换到 kernel mode。当用户程序执行系统调用时，会通过 <code>syscall</code> 触发一个<strong>软中断</strong>（software interrupt），让程序陷入内核天。软中断会查询操作系统预先设定的<strong>中断向量表</strong>，并执行中断向量表中包含的<strong>中断处理程序</strong>。中断处理程序在内核中，这样就完成了 user mode 到 kernel mode 的切换，并执行用户程序想要执行的特权指令。</p><blockquote><p>ECALL 可以让应用程序将控制权转移给内核。它接收一个数字，岱庙应用程序想要调用的系统调用。</p></blockquote><p>比如 ls 程序运行的时候，会调用 <code>read/write</code> 系统调用，Shell 程序会调用 fork 或者 exec 系统调用</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3><p>用户态进程的多线程复用一个内核线程，这样极大地减少了创建内核态线程的成本，但是线程不能并发。因此很少使用。</p><h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p>一对多模型是为每个用户态的线程分配一个单独的内核态线程。在这种情况下，每个用户态线程都需要通过系统调用创建一个绑定的内核线程。这种模型允许所有线程并发执行，能够充分利用多核优势，但是因为线程比较多，对内核调度的压力明显增加。</p><h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p>多对多模型会为 n 个用户态线程分配 m 个体内核态线程。m 通常小于 n，一般 m 为核数。这种关系减少了内核线程，同时保证了多核心并发</p><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>假设我们有两个线程分别执行下面两段程序</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>: <span class="built_in">A</span>() &#123;</span><br><span class="line"><span class="built_in">B</span>();<span class="number">104</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">200</span>: <span class="built_in">B</span>() &#123;</span><br><span class="line"><span class="built_in">yield</span>();<span class="number">204</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">300</span>: <span class="built_in">C</span>() &#123;</span><br><span class="line"><span class="built_in">D</span>();<span class="number">304</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">400</span>: <span class="built_in">D</span>() &#123;</span><br><span class="line"><span class="built_in">yield</span>();<span class="number">404</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们做出如下规定：</p><ul><li><code>100: A()</code> 表示 A 方法的地址为 400；</li><li><code>B();104:</code> 表示 B 方法返回的地址，即压入栈帧中的地址</li><li><code>yield()</code> 表示线程切换</li></ul><p>所以，为了了解线程切换，我们只需要了解 <code>yield</code> 函数应该如何实现。为了方便说明，我们将上面的线程称之为线程 A，将下面的线程称之为线程 B。</p><h3 id="用户线程之间切换"><a href="#用户线程之间切换" class="headerlink" title="用户线程之间切换"></a>用户线程之间切换</h3><p>我们先来模拟一下函数的执行过程。</p><p>首先 A() 方法中调用 B() 方法，此时会将 B 方法的返回地址 104 压栈，然后执行 B 方法。B 方法调用 yield() 方法进行方法切换，将返回地址 204 压栈，然后执行 yield() 方法。</p><p>我们的目标是通过线程 A 的 yield() 方法，让线程 A 的 B() 方法跳转到线程 B 的 C() 方法中执行。我们初步可以实现下面这行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">yield</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">找到 <span class="number">300</span>;</span><br><span class="line">jmp <span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在继续模拟。程序跳转到 300:C() 方法后，将 D() 方法的地址 304 压栈，执行 D() 方法，然后调用 <code>yield()</code> 方法，将地址 404 压栈，切换到线程 A。</p><p>对于线程 B 的 yield() 方法，我们可以这样编写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">yield</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">找到 <span class="number">204</span>;</span><br><span class="line">jmp <span class="number">204</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在栈的状态如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/crwen/img/blog/wrong_schedule.png" alt="image"></p><p>线程 B 的 yield() 方法会跳到 204 执行，然后遇到右大括号，执行 <code>ret</code> 指令弹栈，回将栈顶的 404 弹栈，结果又回到了 D() 方法中，遇到右大括号，又回到 C() 方法中继续执行。这样就出现了问题。</p><p>为什么会产生问题呢？因为两个线程共用了一个栈。所以为了解决问题，每个线程都应该分配一个栈。当执行完 D() 中的 yield() 方法时，两个线程的线程栈应该处于如下状态</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">104</span>|<span class="string">  </span>|<span class="string">304</span>|</span><br><span class="line">|<span class="string">204</span>|<span class="string">  </span>|<span class="string">404</span>|</span><br><span class="line">-----  -----</span><br></pre></td></tr></table></figure><p>此时我们执行线程 B 的 yield() 方法时需要切换线程栈，代码的大致流程如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void yield<span class="literal">()</span> &#123;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">TCB_B</span>.</span></span>esp = esp;</span><br><span class="line">esp = <span class="module-access"><span class="module"><span class="identifier">TCB_A</span>.</span></span>esp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时又轮到线程 A 执行，线程 A 遇到 B() 方法的右大括号，将 204 弹栈，回到 A() 方法，向下执行，接着弹栈。</p><p>由此我们可以得出一个结论，<strong>每个线程都拥有一个栈，切换线程的时候线程栈也需要切换</strong>。</p><p>光有线程栈还不够，我们还需要有一个设备存储当前线程执行指令的为止，方便执行下一条指令。这个设备叫做程序计数器。同时，我们还需要有一些寄存器，用来保存变量，以方便线程切换回来后可以准确地继续执行。以上这些信息都会存储到线程的 TCB 中，线程切换时，只需要切换线程的 TCB 即可。</p><p>通过上面内容，我们知道 TCB 中会包含如下内容：</p><ul><li>程序计数器 PC，标识当前线程执行指令的为止</li><li>保存变量的寄存器</li><li>线程栈，记录函数调用的记录，并反映了当前线程的执行点</li></ul><h3 id="内核线程切换"><a href="#内核线程切换" class="headerlink" title="内核线程切换"></a>内核线程切换</h3><p>通过上面对 user mode 和 kernel mode 的介绍，我们知道，如果想要使用特权指令，就需要使用系统调用，进入内核态，即需要从用户态线程切换到内核态线程。</p><p>如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的内核线程就会被激活。这个切换过程被称之为 上下文切换。在上下问切换前，我们需要保存线程上下文，即保存线程栈、寄存器等信息。之后 CPU 就会被切换到内核栈上运行，内核会运行一段时间处理系统调用或者执行中断处理程序。在处理完成之后返回用户空间时，又会使用之前保存的线程上下文来恢复用户线程状态。</p><p>如果我们需要从一个进程的线程切换到另一个进程的线程，那么我们需要先从进程的用户级线程切换到进程的内核级线程，再从进程的内核级线程切换到另一个进程的内核线程。之后在第二个进程的内核线程中返回到第二个进程的用户及线程。在这个切换中，在用户栈切换的同时，内核栈也跟着切换了。这个切换涉及到了进程的切换，所以还需要切换进程的映射表等信息。</p><p>【参考资料】</p><p><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT 操作系统</a></p><p><a href="http://www.icourse163.org/course/HIT-1002531008">哈工大 操作系统 李治军</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;进程是操作系统的核心，通过进程基本可以将操作系统的所有知识联系起来。而线程是一种轻量级的线程，学习线程对学习进程是很有帮助的。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://crwen.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://crwen.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://crwen.github.io/2021/03/18/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>http://crwen.github.io/2021/03/18/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</id>
    <published>2021-03-17T17:39:16.000Z</published>
    <updated>2021-03-19T17:35:05.656Z</updated>
    
    <content type="html"><![CDATA[<p>什么是虚拟内存？维基百科是这样介绍的</p><blockquote><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换</p></blockquote><span id="more"></span><h2 id="传统内存分配"><a href="#传统内存分配" class="headerlink" title="传统内存分配"></a>传统内存分配</h2><p>在早些时期是没有虚拟内存这个概念的，那时候的计算机所访问的内存地址就是真实的物理地址。这样也许会很方便，但是这要求程序员清除地知道每一块内存是用来做什么的，这样难免会出现问题。</p><ul><li><strong>地址空间不隔离</strong>：所有程序都可以直接访问物理地址，程序所使用的内存空间都是不隔离的。程序可以有意无意地修改其他程序的内存数据</li><li><strong>内存使用效率低</strong>：因为没有有效的内存管理机制，通常一个程序执行时，监控程序将整个程序装入内存中执行。如果内存不够用，就不能运行该程序。一个解决的办法是将其他程序写入磁盘，等到要用时再写回内存。这种情况下，程序需要的是连续的空间，所以换入换出的也是整个程序的空间，这样大量数据的换入换出效率是十分低下的。</li><li><strong>程序运行的地址不确定</strong>：因为程序每次装入时，我们都需要为其分配一块足够大的空间，而这个空闲空间是不确定的，当程序重定位时就会出现错误。</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>有什么办法解决上面这些问题呢？我们知道，计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决（如果还不能解决就再添加一层.jpg）。所以，我们可以在程序与物理空间之间添加一层虚拟地址，让程序操作<strong>虚拟地址</strong>，让后将虚拟地址映射到真实的物理地址上。这个虚拟地址使得应用程序认为它拥有连续可用的内存，这个内存就是<strong>虚拟内存</strong>。顺便附上 IBM 关于虚拟的解释</p><blockquote><p>   它存在，你看得见，它是物理的</p><p>   它存在，你看不见，它是透明的</p><p>   它不存在，你看得见，它是虚拟的</p><p>   它不存在，你看不见，它被删除</p></blockquote><p>在任何时刻，虚拟内存的页面被分为三种：</p><ul><li>未分配的：系统还没有分配的页，即没有任何数据与其关联，不占用磁盘空间</li><li>未缓存的：没有缓存在物理存储器中的已分配的页，即不再内存中的页</li><li>缓存的：当前缓存在物理存储器中的已分配的页，即在内存中的页</li></ul><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在编写程序时，我们倾向于从逻辑功能的角度去考虑，将程序分为多个逻辑功能段，每个段都有自己的段名与对应的段号，比如数据段、代码段、堆栈段等。在分配的时候都是以段位单位进行分配的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[D]|&lt;A&gt;</span><br><span class="line">STORE 1，[X]|&lt;B&gt;</span><br></pre></td></tr></table></figure><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>每个段都对应一个段号，每个段的段号与段基址等信息形成了一个段表。CPU 在寻址的时候，会根据段号查询段表，找到每个段的段基址，然后加上段内偏移量得到需要访问的地址</p><p><img src="https://cdn.jsdelivr.net/gh/crwen/img/img/segment.png" alt="image"></p><h3 id="段保护"><a href="#段保护" class="headerlink" title="段保护"></a>段保护</h3><p><strong>越界中断处理</strong></p><p>进程在执行过程中，有时候需要扩大分段，比如数据段。由于要访问的地址超出原有的段长，所以会引发越界中断。操作系统处理中断时，首先判断该段的 “扩充位” 是否可扩充，如果可扩充，则增加段的长度，否则按出错处理。</p><p><strong>缺段中断处理</strong></p><p>检查内存中是否有足够的空闲空间</p><ul><li>有，则装入该段，修改有关数据结构，中断返回</li><li>没有，检查内存中空闲区总和是否满足需求，如果满足，内存进行内存紧缩，否则淘汰一些段。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>分段的方法解决了上述第 1 和第 3 个问题，即地址空间不隔离问题和程序运行地址不确定问题。实际上这两个问题都是虚拟空间解决的问题。</p><p>但是分段并没有解决第二个问题，即内存使用效率问题。分段对内存区域的映射还是按照程序为单位的，如果内存不足，换入换出的依然是整个程序。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>实际上，根据程序局部性原理，当一个程序在运行时，在某个时间端内，它只是频繁地用到了一小部分数据，也就是说程序的很多数据在一个时间端内都是不会被用到的。所以我们可以使用更小粒度的内存分割和映射方法，提高内存的利用率。这种方法就是<strong>分页</strong>。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>分页的基本方法就是将地址空间等分为固定大小的页，物理内存也被分割为固定大小的页，每一页称之为<strong>页框/页帧/物理块/内存块</strong>。虚拟内存的每一页都会映射到对应的物理空间。这样我们就可以把常用的数据和代码页装入到内存中，把不常用的代码和数据换出到磁盘中。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>程序的每一个页都会映射到物理内存中的页框上，这是需要有一个表存储页号到页框号的映射，这个表就是<strong>页表</strong>，页表中的每一项称之为页表项。页表也是存放在内存中的，并且需要 CPU 中的一些寄存器存放页表在物理内存中的地址。当需要将一个虚拟地址转换为物理地址时，MMU 会自动查询页表，找到页面对应物理内存的页框号，这样就能够实现虚拟地址到物理地址的转换了。</p><p>每个进程都会有自己独立的页表，并且每个进程只能访问出现在自己页表中的物理内存。操作系统会设置页表，使得每个进程都拥有不重合的物理内存，这样一个程序就不能访问其他进程的物理内存了，因为其他进程的物理地址都不在它的页表中。</p><p>当操作系统刚启动时，会没有可用的页，操作系统会设置好内核使用的虚拟地址空间。当用户态进程创建时，内核会将内核页表复制到进程的页表中，所以所有的内核线程相当于都是使用的同一个内核页表。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>一个页一的大小一般为 4K。一个 32 为的机器的寻址能力为 32 位，这就说明 32 位机器的地址空间将有 2<sup>32</sup>/2<sup>12</sup>=2<sup>20</sup> 个页表项，那么将占用 4M（32bit * 2<sup>20</sup>）内存来存储页表项。这个代价太大了。</p><p>为了解决页表项过多的问题，引入了多级页表，即将页表项分为一级页表，一级页表有关联到二级页表，以此类推。这样就只需要 4K 的空间来存储页表了。</p><p>假设采用二级页表的方式，每一级页表使用 10 bit。那么 1 个页目录项可以关联到 2<sup>10</sup> 个地址空间，也就是说一个目录页可以关联到 2<sup>20</sup> 个地址空间。这时页表需要占用 2<sup>10</sup>*2<sup>10</sup> + 4K= 4.004M 的大小。这不是占用更大的内存了吗？这主要有两点原因</p><p><strong>1. 二级页表可以不存在</strong></p><p>实际上二级页表可以不存在。如果一级页表的页表项没有被用到，就不用创建这个页表项对应的二级页表了，即在需要时才创建二级页表。</p><p>那在不分级的页表中，如果页表项没有被用到，可不可以不创建呢？可以，但是不应该这样做。页表的职责时将虚拟地址翻译成物理地址，假如虚拟地址在页表中找不到对应的页表项，会发生错误，所以我们需要保证页表的寻址能力。那么我们能不能不将页表项顺序存放呢？如果不讲页表项顺序存放，我们每次访存的时候就需要遍历页表，这个操作带来的开销是十分巨大的。</p><p><strong>2. 二级页表可以不在主存中</strong></p><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>在多级页表中，我们虽然节省了内存，但是却增加了访存的次数。假设使用二级页表，我们需要先从一级页表中找到目录项，然后再从二级页表中找到对应的页框号，最后，我们需要访问真实的物理内存，在一次寻址中我们进行了 3 次访问内存的操作。我们知道相对于 CPU 来说，访问内存是一个很慢的操作，所以如果有一个缓存能够缓存结果，那么将会大大提高效率。快表（Translation Lookside Buffer，TLB）就提供了这样的功能。</p><p>当进行了一次访存后，TLB 会记录虚拟地址到物理地址的映射。下次访问这个地址后，会从 TLB 中读取到对应的物理地址，直接进行访存。</p><h2 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h2><p>段式存储方便了程序的管理，但是内存使用效率低下。页式存储虽然能够解决内存使用效率低下的问题，但是并不能方便程序的管理。一次人们将段式存储与页式存储相结合，这就是段页式存储了。</p><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>段页式的基本思想是将程序分段，将段分页，这样既可以方便程序的编写，也可方便了内存的管理。</p><p><img src="https://cdn.jsdelivr.net/gh/crwen/img/blog/address.png" alt="image"></p><p>【参考资料】</p><p><a href="https://book.douban.com/subject/3652388/">程序员的自我修养</a></p><p><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT 操作系统</a></p><p><a href="https://www.zhihu.com/question/63375062/answer/1403291487">操作系统中的多级页表到底是为了解决什么问题</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是虚拟内存？维基百科是这样介绍的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://crwen.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://crwen.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer</title>
    <link href="http://crwen.github.io/2021/03/17/AbstractQueuedSynchronizer/"/>
    <id>http://crwen.github.io/2021/03/17/AbstractQueuedSynchronizer/</id>
    <published>2021-03-17T10:42:04.000Z</published>
    <updated>2021-03-17T14:03:32.220Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>AbstractQueuedSynchronizer 就是大名鼎鼎的 AQS，juc 包下很多类都会使用到这个类，所以了解这个类对 Java 并发编程的学习是很有帮助的。下面我们就来介绍以下 AQS</p><span id="more"></span><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><strong>简单属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步器的状态，子类会根据状态字段进行判断是否可以获得锁</span></span><br><span class="line"><span class="comment">// 比如 CAS 成功给 state 赋值 1 算得到锁，失败为得不到锁， CAS 成功给 state 赋值 0 算释放锁，失败为释放失败</span></span><br><span class="line"><span class="comment">// 可重入锁，每次获得锁 +1，每次释放锁 -1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋超时阀值，单位纳秒</span></span><br><span class="line"><span class="comment">// 当设置等待时间时才会用到这个属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure><p><strong>同步队列属性</strong></p><p>所谓同步队列，就是指当多个线程请求锁的时候，在某一时刻有且只有一个线程能够获得锁，剩余线程都会加到同步队列中排队并阻塞。当有线程主动释放锁时，就会从同步队列队首开始释放一个排队的线程，让线程重新去竞争锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步队列的头。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步队列的尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><p><strong>条件队列属性</strong></p><p>条件队列和同步队列的功能一样，管理获取步到锁的线程，但是条件队列不直接和锁打交道，但经常和锁配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">// 条件队列中第一个 node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 条件队列中最后一个 node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>Node</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步队列单独的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//node 是共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node 是排它模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的前驱节点</span></span><br><span class="line">    <span class="comment">// 节点 acquire 成功后就会变成head</span></span><br><span class="line">    <span class="comment">// head 节点不能被 cancelled</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个队列共享的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 表示当前节点的状态，通过节点的状态来控制节点的行为</span></span><br><span class="line">    <span class="comment">// 普通同步节点，就是 0 ，条件节点是 CONDITION -2</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus 的状态有以下几种</span></span><br><span class="line">    <span class="comment">// 被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIGNAL 状态的意义：同步队列中的节点在自旋获取锁的时候，如果前一个节点的状态是 SIGNAL，那么自己就可以阻塞休息了，否则自己一直自旋尝试获得锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前 node 正在条件队列中，当有节点从同步队列转移到条件队列时，状态就会被更改成 CONDITION</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无条件传播,共享模式下，该状态的进程处于可运行状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在同步队列中，nextWaiter 并不真的是指向其下一个节点，我们用 next 表示同步队列的下一个节点，nextWaiter 只是表示当前 Node 是排它模式还是共享模式</span></span><br><span class="line">    <span class="comment">// 但在条件队列中，nextWaiter 就是表示下一个节点元素</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><h3 id="acquire-排他锁"><a href="#acquire-排他锁" class="headerlink" title="acquire 排他锁"></a>acquire 排他锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire 由实现类实现，一般都是 CAS 给 state 赋值来决定是否能够获取到锁</span></span><br><span class="line">    <span class="comment">// 尝试以排他模式 CAS 加入同步队列队尾，然后将当前节点的前驱节点设置文 SIGNAL，然后阻塞自己</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 <code>acquire</code> 方法里面，先尝试获取锁，如果获取锁失败，尝试将线程放进同步队列中。放入同步队列的过程有两步：1. 调用 <code>addWaiter</code> 把当前线程放到同步队列队尾。2. 调用 <code>acquireQueued</code>，使当前节点阻塞</p><p><code>addWaiter</code> 的逻辑很简单，就是将当前节点插入到同步队列的队尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS 将 node 作为尾节点，因为 CAS 大多会一次成功，如果失败了再进行自旋</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">            pred.next = node; </span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prev 为空，或者 CAS 失败</span></span><br><span class="line">    <span class="comment">// 自旋，采用 CAS 尝试将 当前节点加入到队尾</span></span><br><span class="line">    enq(node); </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果为空表示同步队列还没初始化，进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CAS 将 node 设置为尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter</code> 主要做了两件事情</p><ul><li>将 mode 封装为一个 Node</li><li>利用 CAS + 自旋操作，将节点添加到同步队列队尾。如果头结点为空，先进行队列的初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点就是根节点，就尝试获取锁，如果成功就把自己设置为头结点</span></span><br><span class="line">            <span class="comment">// p=head可能是因为在enq方法中队列才进行初始化，这时锁没有被占用。所以这时可以尝试获取锁</span></span><br><span class="line">            <span class="comment">// 也有可能是前驱节点持有锁，这是获取锁可能失败，会进入获取锁失败的流程</span></span><br><span class="line">            <span class="comment">// 也有可能是节点之前被阻塞，然后被唤醒，此时头结点正好是节点的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取锁失败，或者前驱节点不是头结点</span></span><br><span class="line">            <span class="comment">// 判断是否应该自旋，如果前驱节点的状态为 SIGNAL，则当前节点就可以阻塞了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 使用 LockSupport.park 挂起线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireQueued</code> 方法主要做了以下几件事情</p><ul><li>判断前驱节点是否为 head 节点，如果是，尝试获取锁。</li><li>如果前驱节点不是 head 节点，或者获取锁失败，将前驱节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果当前前驱节点状态为 SIGNAL，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果节点被取消了，移除节点，直到找到一个没有被取消的节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 ws &lt;= 0，直接把节点设置为 SIGNAL</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 大致分为三步：</p><ol><li>使用 <code>tryAcquire</code> 方法尝试获取锁，成功直接返回，否则走 2</li><li>把当前节点加入同步队列队尾</li><li>自旋，将当前节点的前驱节点设置为 SIGNAL，然后阻塞自己</li></ol><p><img src="/2021/03/17/AbstractQueuedSynchronizer/note\fighting\Java\并发\AQS\assets\aqs独占锁获取.jpg" alt="img"></p><h3 id="释放排他锁-release"><a href="#释放排他锁-release" class="headerlink" title="释放排他锁 release"></a>释放排他锁 release</h3><p>排他锁的释放比较简单，从队头开始，找到它的下一个节点，如果下一个节点是空的，就会从队尾开始，一直找到状态节点不是取消的节点，然后释放该节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryRelease 由子类实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果头结点不为空，并且不是初始化状态</span></span><br><span class="line">        <span class="comment">// 如果为初始化状态，可能是因为只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 从头唤醒等待锁的节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// node 为当前释放锁的节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 更新为普通节点</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果后继节点为空，或者后继节点已经被取消了</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾节点开始遍历，直到找到一个没有被取消的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) </span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// 唤醒</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放节点后，将继续执行 <code>acquireQueued</code> 中的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="comment">// 如果前驱节点就是根节点，就尝试获取锁，如果成功就把自己设置为头结点</span></span><br><span class="line">    <span class="comment">// p=head可能是因为在enq方法中队列才进行初始化，这时锁没有被占用。所以这时可以尝试获取锁</span></span><br><span class="line">    <span class="comment">// 也有可能是前驱节点持有锁，这是获取锁可能失败，会进入获取锁失败的流程</span></span><br><span class="line">    <span class="comment">// 也有可能是节点之前被阻塞，然后被唤醒，此时头结点正好是节点的前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败，或者前驱节点不是头结点</span></span><br><span class="line">    <span class="comment">// 判断是否应该自旋，如果前驱节点的状态为 SIGNAL，则当前节点就可以阻塞了</span></span><br><span class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">        parkAndCheckInterrupt()) <span class="comment">// 使用 LockSupport.park 挂起线程</span></span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h3 id="acquireShared-获取共享锁"><a href="#acquireShared-获取共享锁" class="headerlink" title="acquireShared 获取共享锁"></a>acquireShared 获取共享锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以共享模式加入到同步队列队尾</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点就是头节点，就尝试获取锁，</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取锁成功，把当前节点设置为头结点，并唤醒</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前驱节点不是 头结点</span></span><br><span class="line">            <span class="comment">// 前驱节点是 头结点，但是当前节点获取锁失败</span></span><br><span class="line">            <span class="comment">// 判断是否应该自旋，如果前驱节点的状态为 SIGNAL，则当前节点就可以阻塞了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node); <span class="comment">// 将当前节点设置为头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果后继节点也是共享模式，就唤醒或者后继节点为空，唤醒后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取共享锁的逻辑大致如下：</p><ol><li>尝试获取共享锁，成功直接返回，否则走 2</li><li>封装为节点，加入同步队列尾部，走 3</li><li>如果前驱节点是头结点，再次尝试获取共享锁，成功走 4，否则走 5</li><li>将当前节点设置为头结点并唤醒，返回</li><li>将当前节点的前驱节点设置为 SIGNAL，然后阻塞</li></ol><p><code>setHeaderAndPropagate</code> 这个方法主要做了两件事情：</p><ul><li>将当前节点设置为新的头结点，这就意味着前驱节点已经获取了共享锁</li><li>唤醒后继节点</li></ul><h3 id="释放共享锁"><a href="#释放共享锁" class="headerlink" title="释放共享锁"></a>释放共享锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared(); <span class="comment">// 释放共享锁成功，唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒后继节点，唤醒后继续自旋逻辑，尝试获取锁</span></span><br><span class="line">                unparkSuccessor(h); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果后继节点暂时不需要唤醒，将状态设置为 PROPAGATE，方便传递给后继节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 可能是 setHeadAndPropagate 中调用的该方法，head 发生改变，唤醒该节点</span></span><br><span class="line">        <span class="comment">// 2. releaseShared 中调用，head 不会改变，直接退出循环，释放锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;AbstractQueuedSynchronizer 就是大名鼎鼎的 AQS，juc 包下很多类都会使用到这个类，所以了解这个类对 Java 并发编程的学习是很有帮助的。下面我们就来介绍以下 AQS&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://crwen.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
